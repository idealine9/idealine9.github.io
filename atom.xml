<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>idealine的博客</title>
  
  <subtitle>遇到不会的就去学,而不只是跪地上膜拜大佬.</subtitle>
  <link href="https://idealine9.github.io/atom.xml" rel="self"/>
  
  <link href="https://idealine9.github.io/"/>
  <updated>2023-12-26T03:16:27.537Z</updated>
  <id>https://idealine9.github.io/</id>
  
  <author>
    <name>idealine9</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Arduino Uno驱动12864屏幕</title>
    <link href="https://idealine9.github.io/posts/Arduino_Uno_12864/"/>
    <id>https://idealine9.github.io/posts/Arduino_Uno_12864/</id>
    <published>2023-12-26T01:26:02.043Z</published>
    <updated>2023-12-26T03:16:27.537Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>用Arduino Uno驱动12864屏幕，实现简单动画</p></blockquote><span id="more"></span><p>参照B站视频：BV1bP41187UF</p><p><strong>所需硬件：</strong></p><ul><li>Arduino Uno</li><li>4针OLED显示屏/IIC接口，SH1106控制芯片</li></ul><p><strong>连线方式：</strong></p><p>Arduino Uno的<strong>5V</strong>——显示屏的<strong>Vcc</strong></p><p>Arduino Uno的<strong>GND</strong>——显示屏的<strong>GND</strong></p><p>Arduino Uno的<strong>A4</strong>——显示屏的<strong>SDA</strong></p><p>Arduino Uno的<strong>A5</strong>——显示屏的<strong>SCL</strong></p><p><strong>连线图：</strong></p><p><img src="/images/Arduino_madeline/link.png" /></p><p>​</p><p><strong>Arduino IDE设置</strong></p><p>在Arduino IDE的库管理中查找并安装对应的库，比如用到的U8g2库。</p><p><img src="/images/Arduino_madeline/ide.png" /></p><p>接下来打开一个网站：<ahref="https://www.photopea.com/">photopea.com</a></p><p>将你想要做成动画的gif或者视频放入里面，分解为单独的帧后以图层的方式导出，记得稍微调整一下导出图层的尺寸。</p><p>​</p><p>之后在另外一个网站：<ahref="https://javl.github.io/image2cpp/">image2cpp</a></p><p>将得到的图层放入后在最底下点击Generate code，得到代码。</p><p>​</p><p>最后打开Arduino IDE，编写代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Arduino.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;U8g2lib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wire.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">U8G2_SH1106_128X64_NONAME_F_HW_I2C <span class="title">u8g2</span><span class="params">(U8G2_R0, U8X8_PIN_NONE)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将你得到的代码放在这里</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g2.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  u8g2.<span class="built_in">clearBuffer</span>();</span><br><span class="line">  u8g2.<span class="built_in">drawXBMP</span>(<span class="number">32</span>, <span class="number">0</span>, <span class="number">64</span>, <span class="number">64</span>, epd_bitmap_allArray[count]);</span><br><span class="line">  u8g2.<span class="built_in">sendBuffer</span>();</span><br><span class="line"></span><br><span class="line">  count = (count + <span class="number">1</span>) % epd_bitmap_allArray_LEN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>在上面第18行代码中的两个64分别设置的输出尺寸，记得和image2cpp中的尺寸对应。</p><p>在得到的代码中会有一个epd_bitmap_allArray[]数组,数组下标即为播放的指定帧。</p><p>为实现循环效果,下标用count变量代替，后面对count进行不断的自增和取模,实现循环。</p><p>在得到的代码中有一个const修饰的int类型变量epd_bitmap_allArray_LEN，是上面数组的大小，也就是帧的数量。</p><p>让count每次+1并对这个变量取模，实现循环播放所有帧。</p><p>​</p><p>B站视频讲的比较清晰，由于我买的是不同控制芯片的显示屏，在过程中发现了一堆问题故写了一个简单博客来记录处理方式与不同版本的代码。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;用Arduino Uno驱动12864屏幕，实现简单动画&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="硬件技巧" scheme="https://idealine9.github.io/categories/%E7%A1%AC%E4%BB%B6%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="硬件" scheme="https://idealine9.github.io/tags/%E7%A1%AC%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>判断图是否为DAG</title>
    <link href="https://idealine9.github.io/posts/C++_DAG/"/>
    <id>https://idealine9.github.io/posts/C++_DAG/</id>
    <published>2023-09-10T11:24:36.317Z</published>
    <updated>2023-12-26T03:09:41.132Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>C++ 判断图是否为DAG</p></blockquote><span id="more"></span><p><strong>DAG</strong>, 即 <em>Directed Acyclic Graphs</em>(有向无环图)， 在有向图的基础上附加了无环 (cycle) 的条件(具体定义可在我的MCS笔记中找到)。</p><p><strong>DAG</strong> 非常重要的一点特性是：每一个有限的<strong>DAG</strong> 都存在<strong>拓扑排序</strong> (<em>Topologicalsorting</em>)，拓扑排序可以很好的解决如课程表、任务调度等这些具有依赖关系的问题。</p><p>基本算法思想是，通过<strong>深度优先搜索</strong>(DFS)，顺着某一顶点一直往下搜，看是否会搜索到之前已经遇到过的顶点，若能遇到，则说明存在环；若没有遇到，则说明不存在环，该图则可以进行拓扑排序。</p><p>C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; visited;                     <span class="comment">//用来记录当前顶点是否已经遍历的状态数组</span></span><br><span class="line"><span class="type">bool</span> no_exist_cycle = <span class="literal">true</span>;              <span class="comment">//判断是否存在环，默认为不存在</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;&amp; G, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    visited[u] = <span class="number">1</span>;                      <span class="comment">//设为1，状态为：遍历中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : G[u]) &#123;                 <span class="comment">//遍历顶点u所依赖的点</span></span><br><span class="line">        <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(G, v);</span><br><span class="line">            <span class="keyword">if</span> (!no_exist_cycle) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;      <span class="comment">//当DFS又遍历到前面正在遍历中的点，则说明存在环</span></span><br><span class="line">            no_exist_cycle = <span class="literal">false</span>;      <span class="comment">//存在环</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[u] = <span class="number">2</span>;                      <span class="comment">//出循环后将visited[u]置不为0或1，状态为：已遍历过</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">G</span>(<span class="number">7</span>);          <span class="comment">//创建有向图G</span></span><br><span class="line">    G[<span class="number">0</span>] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;                    <span class="comment">//意思是顶点0指向的顶点有2、4、5，即0-&gt;2等，下同</span></span><br><span class="line">    G[<span class="number">1</span>] = &#123;<span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    G[<span class="number">2</span>] = &#123;&#125;;</span><br><span class="line">    G[<span class="number">3</span>] = &#123;<span class="number">5</span>&#125;;</span><br><span class="line">    G[<span class="number">4</span>] = &#123;&#125;;</span><br><span class="line">    G[<span class="number">5</span>] = &#123;<span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    G[<span class="number">6</span>] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    visited.<span class="built_in">resize</span>(G.<span class="built_in">size</span>());            <span class="comment">//状态数组的大小与G的顶点数相同</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.<span class="built_in">size</span>() &amp;&amp; no_exist_cycle; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(G, i);                   <span class="comment">//对每个没有访问过的顶点进行DFS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (no_exist_cycle) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;G is a DAG.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;G is not a DAG.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相似问题：</p><p><a href="https://leetcode.cn/problems/course-schedule/">LeetCode_207.课程表</a></p><p><ahref="https://leetcode.cn/problems/course-schedule-ii/">LeetCode_210.课程表 II</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;C++ 判断图是否为DAG&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="算法技巧" scheme="https://idealine9.github.io/categories/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/"/>
    
    
    <category term="算法" scheme="https://idealine9.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Mathematics for Computer Science</title>
    <link href="https://idealine9.github.io/posts/MCS/"/>
    <id>https://idealine9.github.io/posts/MCS/</id>
    <published>2023-08-22T03:03:20.441Z</published>
    <updated>2023-12-26T03:08:48.030Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>MCS的一点阅读笔记（更新时间：2023-12-26）</strong><span id="more"></span></p></blockquote><h2 id="state-machine">6. State Machine</h2><p>A <em>state machine</em> is a binary relation on a set, the elementsof the set are called '<em>states</em>', the relation is called the<em>transition relation</em>, an arrow in the graph of the transitionrelation is called a <em>transition</em>. The transition relation iscalled the <em>state graph</em> of the machine. A state machine alsocomes equipped with a designated <em>start state</em>.</p><h3 id="invariant-principle">6.2 Invariant Principle</h3><p>A state machine <em>execution</em> describes a possible sequence ofsteps a machine might take.</p><blockquote><p><strong>Definition</strong> 6.2.4</p><p>An execution of thee state machine is a (possible infinite) sequenceof states with the propperty that</p></blockquote><ul><li>it begins with the start state</li><li>if <span class="math inline">\(q\)</span> and <spanclass="math inline">\(r\)</span> are consecutive states in thesequences, then <span class="math inline">\(q \rightarrow r\)</span>.</li></ul><p>A state is called <em>reachable</em> if it appears in someexecution.</p><blockquote><p><strong>Definition</strong> 6.2.5</p><p>A <em>preserved invariant</em> of a state machine is a predicate<span class="math inline">\(P\)</span> on states, such that whenever<span class="math inline">\(P(q)\)</span> is true of a state <spanclass="math inline">\(q\)</span> and <span class="math inline">\(q\rightarrow r\)</span> for state <span class="math inline">\(r\)</span>,then <span class="math inline">\(P(r)\)</span> holds.</p></blockquote><p><strong>The Invariant Principle</strong></p><p>If a preserved invariant of a state machine is true for the startstate, then it is true for all reachable states.</p><h2 id="group-theory">10. Group theory</h2><h3 id="directed-graph">Directed graph</h3><h4 id="vertex-degrees">10.1 Vertex Degrees</h4><p>The <span class="math inline">\(in {-} degree \ (d^-)\)</span> is thenumber of arrows coming into it ( <em>number of times the vertex ispointed</em> ),</p><p>similarly, the <span class="math inline">\(out{-}degree \(d^+)\)</span> is the number of arrows out of it ( <em>number of pointsto other vertices</em> ).</p><p>If <span class="math inline">\(G\)</span> is a digraph and <spanclass="math inline">\(v \in V(G)\)</span> , then <spanclass="math display">\[\sum_{v \ \in \ V(G)} d^+(v) = \sum_{v \ \in \ V(G)} d^-(v)\]</span> and both sums are equal to <span class="math inline">\(\vertE(G) \vert\)</span></p><h4 id="walks-and-paths">10.2 Walks and Paths</h4><blockquote><p><strong>Definition 10.2.1</strong></p><p><strong><span class="math inline">\(walk\)</span></strong> : A <spanclass="math inline">\(walk\)</span> in a digraph is an alternatingsequence of vertices and edges that begins with a vertex and ends with avertex.</p><p><strong><span class="math inline">\(closed \ walk\)</span></strong> :A <span class="math inline">\(closed \ walk\)</span> is a <spanclass="math inline">\(walk\)</span> that begins and ends at the samevertex.</p><p><strong><span class="math inline">\(path\)</span></strong> : The<span class="math inline">\(walk\)</span> is a <spanclass="math inline">\(path\)</span> iff all the vertices aredifferent.</p><p><strong><span class="math inline">\(cycle\)</span></strong> : A <spanclass="math inline">\(cycle\)</span> is a positive length <spanclass="math inline">\(path\)</span> and begins and ends at the samevertex.</p></blockquote><blockquote><p><strong>Lemma 10.2.5</strong></p><p><em>The Triangle Inequality</em></p></blockquote><p><span class="math display">\[dist(u,v) \le dist(u,x)+dist(x,v)\]</span></p><p>for all vertices <span class="math inline">\(u,\ v, \ x\)</span> withequality holding if and only if x is on a shortest path from <spanclass="math inline">\(u\)</span> to <spanclass="math inline">\(v\)</span>.</p><h4 id="adjacency-matrices">10.3 Adjacency Matrices</h4><p>If a graph <span class="math inline">\(G\)</span> has <spanclass="math inline">\(n\)</span> vertices <spanclass="math inline">\(v_0, \ v_1 \ ... \ v_{n-1}\)</span> , a useful wayto represent it is with an <span class="math inline">\(n \timesn\)</span> matrix of zeros and ones called its <strong><em>adjacencymatrices</em></strong> <span class="math inline">\(A_G\)</span>.</p><p><span class="math inline">\((A_G)_{ij}\)</span> is <spanclass="math inline">\(1\)</span> if there is an edge from vertex <spanclass="math inline">\(v_i\)</span> to vertex <spanclass="math inline">\(v_j\)</span> and <spanclass="math inline">\(0\)</span> otherwise. <spanclass="math display">\[(A_G)_{ij}=\begin{cases}1 &amp; if \ \langle v_i \to v_j \rangle \in E(G),\\0 &amp; otherwise,\end{cases}\]</span></p><p>Let <span class="math inline">\(H\)</span> be the 4-node graph. Itsadjacency matrix <span class="math inline">\(A_H\)</span> is the 4 <spanclass="math inline">\(\times\)</span> 4 matrix : <spanclass="math display">\[A_H \ = \ \ \\begin{array}{}&amp; a &amp; b &amp; c &amp; d \\a &amp; 0 &amp; 1 &amp; 0 &amp; 1 \\b &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\c &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\d &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\\end{array}\]</span> We can use matrix powers to count numbers of walks betweenvertices. For example, if we want to know the walk with a length of<span class="math inline">\(2\)</span>, we could have read these countsfrom the entires in the matrix <spanclass="math inline">\((A_H)^2\)</span> : <span class="math display">\[(A_H)^2 \ = \ \ \\begin{array}{}&amp; a &amp; b &amp; c &amp; d \\a &amp; 0 &amp; 0 &amp; 2 &amp; 1 \\b &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\c &amp; 0 &amp; 0 &amp; 1 &amp; 1 \\d &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\\end{array}\]</span> More generally, the matrix <spanclass="math inline">\((A_G)^k\)</span> provides a count of the number oflength <span class="math inline">\(k\)</span> walks between vertices inany digraph <span class="math inline">\(G\)</span>.</p><blockquote><p><strong>Theorem 10.3.2</strong></p><p>For a digraph <span class="math inline">\(G\)</span>, if <spanclass="math inline">\(C\)</span> is the <em>length-m walk countingmatrix</em> and <span class="math inline">\(D\)</span> is the<em>length-n walk counting matrix</em>, then <spanclass="math inline">\(CD\)</span> is the <em>length k+m walk countingmatrix</em> for <span class="math inline">\(G\)</span>.</p></blockquote><blockquote><p><strong>Corollary 10.3.3</strong></p><p>The <em>length-k counting matrix of a digraph</em> <spanclass="math inline">\(G\)</span> is <spanclass="math inline">\((A_G)^k\)</span> , for all <spanclass="math inline">\(k\in\)</span> <spanclass="math inline">\(\mathbb{N}\)</span>.</p></blockquote><p>In other words, you can determine the number of <em>length <spanclass="math inline">\(k\)</span> walks</em> between any pair of verticessimply by computing the <span class="math inline">\(k\)</span> th powerof the <em>adjacency matrix</em>.</p><h5 id="shortest-path">Shortest Path</h5><p>To find the lengths of all the shortest paths in an <em>n-vertex</em>graph <span class="math inline">\(G\)</span> is to compute thesuccessive powers of <span class="math inline">\(A_G\)</span> one by oneup to the <span class="math inline">\(n-1\)</span> times, watching forthe first power at which each entry becomes positive.</p><p>The distance from <span class="math inline">\(u\)</span> to <spanclass="math inline">\(v\)</span> will be the smallest value <spanclass="math inline">\(k\)</span> for which <spanclass="math inline">\((A_G)^K_{uv}\)</span> is nonzero, and if there isa shortest path, its length will be <span class="math inline">\(\len-1\)</span> . The methods apply as well to <em>weightedgraphs</em>.</p><h4 id="walks-relations">10.4 Walks Relations</h4><p>For any digraph <span class="math inline">\(G\)</span>, a binaryrelation <span class="math inline">\(G^*\)</span>, called the walkrelation on <span class="math inline">\(V(G)\)</span>, where <spanclass="math display">\[u \ G^* \ v ::= \text{there is a walk in $G$ from $u$ to $v$}\]</span></p><h4 id="directed-acyclic-graphsdag-scheduling">10.5 Directed AcyclicGraphs(DAG) &amp; Scheduling</h4><blockquote><p><strong>Definition 10.5.1</strong></p><p>A <strong><em>directed acyclic graph</em></strong> (DAG) is adirected graph with no cycles.</p></blockquote><blockquote><p><strong>Definition 10.5.2</strong></p><p>A <strong><em>topological sort</em></strong> of a<strong>finite</strong> DAG is a list of all the vertices such that eachvertex <span class="math inline">\(v\)</span> appears earlier in thelist than every other vertex reachable form <spanclass="math inline">\(v\)</span>.</p></blockquote><blockquote><p><strong>Definition 10.5.3</strong></p><ol type="1"><li>A vertex <span class="math inline">\(v\)</span> of a DAG <spanclass="math inline">\(G\)</span> is <strong><em>minimum</em></strong> ifand only if every other vertex is reachable from <spanclass="math inline">\(v\)</span>.</li><li>A vertex <span class="math inline">\(v\)</span> of a DAG <spanclass="math inline">\(G\)</span> is <strong><em>minimal</em></strong> ifand only if <span class="math inline">\(v\)</span> is not reachable fromany other vertex.</li></ol></blockquote><blockquote><p><strong>Definition 10.5.4</strong></p><p>Every <strong>finite</strong> DAG has a <strong><em>topologicalsort</em></strong>.</p></blockquote><blockquote><p><strong>Definition 10.5.5</strong></p><p>Two vercices in a DAG are <strong><em>comparable</em></strong> whenone of them is reachable from the other.</p><p>A <strong><em>chain</em></strong> in a DAG is a set of vertices suchthat any two of them are comparable.</p><p>A vertex in a <strong><em>chain</em></strong> that is reachable fromall other vertices in the chain is called a <strong><em>maximumelement</em></strong> of the chain. A finite chain ends at its maximumelement.</p></blockquote><p>A largest chain is also known as a <strong><em>criticalpath</em></strong>.</p><blockquote><p><strong>Definition 10.5.6</strong></p><p>A <strong><em>partition</em></strong> of a set <spanclass="math inline">\(A\)</span> is a set of nonempty subsets of <spanclass="math inline">\(A\)</span> called the <em>blocks</em> of the<em>partition</em>, such that every element of <spanclass="math inline">\(A\)</span> is in exactly one block.</p></blockquote><blockquote><p><strong>Definition 10.5.7</strong></p><p>A <strong><em>parallel schedule</em></strong> for a DAG <spanclass="math inline">\(D\)</span> is a partition of <spanclass="math inline">\(V(D)\)</span> into <em>blocks</em> <spanclass="math inline">\(A_0, A_1,...\)</span> , such that when <spanclass="math inline">\(j&lt;k\)</span> , no vertex in <spanclass="math inline">\(A_j\)</span> is reachable from any vertex in <spanclass="math inline">\(A_k\)</span></p></blockquote><p>For example, one possible <em>partition</em> of the set <spanclass="math inline">\(\{ a,b,c,d,e \}\)</span> into three blocks is<span class="math display">\[\{a,c\} \ \ \ \{b,e\} \ \ \ \{d\}\]</span></p><p>The block <span class="math inline">\(A_k\)</span> is called the setof elements <em>scheduled at step k</em> , and the time of the scheduleis the number of blocks. The maximum number of elements scheduled at anystep is called the <em>number of processors</em> required by theschedule.</p><p>A <em>largest chain</em> ending at an element <spanclass="math inline">\(a\)</span> is called a <em>critical path</em> to<span class="math inline">\(a\)</span>, and the number of elements lessthan <span class="math inline">\(a\)</span> in the chain is called the<em>depth</em> of <span class="math inline">\(a\)</span>.</p><p>So, in any possible <em>parallel schedule</em>, there must be atleast <span class="math inline">\(depth(a)\)</span> steps before task<span class="math inline">\(a\)</span> can be started.</p><p>In particular, the <em>minimal elements</em> are precisely theelements with <strong>depth 0</strong>.</p><h3 id="simple-graph">Simple graph</h3><h4 id="graph-isomorphism">12.4 Graph isomorphism</h4><blockquote><p><strong>Definition 12.4.1</strong></p><p>An isomorphism between graphs <span class="math inline">\(G\)</span>and <span class="math inline">\(H\)</span> is a bijection <spanclass="math inline">\(f : V(G) \rightarrow V(H)\)</span> such that <spanclass="math display">\[\langle u - v \rangle \in E(G) \quad iff \quad \langle f(u)-f(v) \rangle\in E(H)\]</span></p></blockquote><blockquote><p>for all <span class="math inline">\(u,v \in V(G).\)</span> Two graphsare isomorphism when there is an isomorphism between them.</p></blockquote><p><strong>Isomorphism</strong> preserves the <em>connectionproperties</em> of a graph, abstracting out what the vertices arecalled, what they are made out of, or where they appear in the graph.More precisely, a property of a graph is said to be <em>preserved underisomorphism</em> if whenever <span class="math inline">\(G\)</span> hasthat property, every graph isomorphic to <spanclass="math inline">\(G\)</span> also has that property.</p><p>If <span class="math inline">\(f\)</span> is a graph isomorphis, thatmaps a vertex <span class="math inline">\(v\)</span> of one graph to thevertex <span class="math inline">\(f(v)\)</span> of an isomorphic graph,then by definition of isomorphism, every vertex adjacent to <spanclass="math inline">\(v\)</span> in the first graph will be mapped by<span class="math inline">\(f\)</span> to a vertex adjacent to <spanclass="math inline">\(f(v)\)</span> in the isomorphic graph. Thus, <spanclass="math inline">\(v\)</span> and <spanclass="math inline">\(f(v)\)</span> will have the same degree.</p><h4 id="bipartite-graph-matching">12.5 Bipartite Graph &amp;Matching</h4><blockquote><p><strong>Definition 12.5.1</strong></p><p>A <em>bipartite graph</em> is a graph whose vertices can be<em>partitioned into two blocks</em>, <spanclass="math inline">\(L(G)\)</span> and <spanclass="math inline">\(R(G)\)</span> , such that every edge has oneendpoint in <span class="math inline">\(L(G)\)</span> and the otherendpoint in <span class="math inline">\(R(G)\)</span>.</p></blockquote><h5 id="matching">Matching</h5><blockquote><p><strong>Definition 12.5.3</strong></p><p>A <em>matching</em> in a graph is a set of edges <spanclass="math inline">\(M \in E(G)\)</span> such that no two edges in<span class="math inline">\(M\)</span> are incident to the same vertex.The vertices incident to an edge in <spanclass="math inline">\(M\)</span> are said to be <em>coverd</em> by <spanclass="math inline">\(M\)</span>. A matching covers a set of vertices<span class="math inline">\(S\)</span>, each vertex in <spanclass="math inline">\(S\)</span> is a vertex of a matching edge. Amatching is said to be <em>perfect</em> when it covers <spanclass="math inline">\(V(G)\)</span>. The set <spanclass="math inline">\(N(S)\)</span> of neighbors of some set <spanclass="math inline">\(S \in V(G)\)</span> of vertices is the image of<span class="math inline">\(S\)</span> under the edge-relation, thatis</p></blockquote><p><span class="math display">\[N(S) ::= \{ r \ | \ \langle s-r \rangle \in E(G) \ \text{for some} \ s\in S\}\]</span></p><p><span class="math inline">\(S\)</span> is called a<em>bottleneck</em> if <span class="math display">\[\lvert S \rvert &gt; \lvert N(S) \rvert\]</span></p><blockquote><p><strong>Theorem 12.5.4</strong></p><p>(<em>Hall's Theorem</em>) Let <span class="math inline">\(G\)</span>be a bipartite graph. There is a matching in <spanclass="math inline">\(G\)</span> that covers <spanclass="math inline">\(L(G)\)</span> iff no subset of <spanclass="math inline">\(L(G)\)</span> is a bottleneck.</p></blockquote><h4 id="coloring">12.6 Coloring</h4><p>Given a graph <span class="math inline">\(G\)</span> , assign colorsto each node such that adjacent nodes have different colors. A colorassignment with this property is called a <em>valid coloring</em> of thegraph-a "<em>coloring</em>", A graph <spanclass="math inline">\(G\)</span> is <em><spanclass="math inline">\(k\)</span>-colorable</em> if it has a coloringthat uses at most <span class="math inline">\(k\)</span> colors.</p><blockquote><p><strong>Definition</strong> 12.6.1</p><p>The minimum number of colors for which a graph <spanclass="math inline">\(G\)</span> has a valid coloring is called its<em>chromatic number</em>, <spanclass="math inline">\(\chi(G)\)</span>.</p></blockquote><p><span class="math inline">\(G\)</span> is <spanclass="math inline">\(k\)</span>-colorable iff <spanclass="math inline">\(\chi(G) \leq k\)</span>.</p><p>An even-length cycle is 2-colorable: <span class="math display">\[\chi(C_{\text{even}}) = 2\]</span> An odd-length cycle is 3-colorable: <spanclass="math display">\[\chi(C_{\text{odd}}) = 3\]</span></p><p>A complete graph <span class="math inline">\(K_n\)</span> : <spanclass="math display">\[\chi(K_n) = n\]</span> since no two vertices can have the same color.</p><blockquote><p><strong>Lemma 12.6.2</strong></p><p>A nonempty graph <span class="math inline">\(G\)</span> is bipartiteiff <span class="math inline">\(\chi(G) = 2\)</span>.</p></blockquote><blockquote><p><strong>Definition 12.6.3</strong></p><p>A graph with maximum degree at most <spanclass="math inline">\(n\)</span> is <spanclass="math inline">\((n+1)\)</span>-colorable.</p></blockquote><h4 id="walks-in-simple-graph">12.7 Walks in Simple Graph</h4><p>We don't intend that cycles have a beginning or an end, so any of thepaths that go around a cycle can represent it. Furthermore, cycles insimple graphs don't have a direction.</p><p>A precise way to explain which closed walks represent the same cycleis to define a cycle to be <em>subgraph</em> isomorphic to a cycle graph<span class="math inline">\(C_n\)</span>.</p><blockquote><p><strong>Definition 12.7.2</strong></p><p>A graph <span class="math inline">\(G\)</span> is said to be a<em>subgraph</em> of a graph <span class="math inline">\(H\)</span> if<span class="math inline">\(V(G) \subseteq V(H)\)</span> and <spanclass="math inline">\(E(G) \subseteq E(H)\)</span>.</p></blockquote><h4 id="connectivity">12.8 Connectivity</h4><blockquote><p><strong>Definition 12.8.1</strong></p><p>Two vertices are connected in a graph when there is a path thatbegins at one and ends at the other. A graph is <em>connected</em> whenevery pair of vertices are connected.</p></blockquote><h5 id="connected-components">Connected Components</h5><blockquote><p><strong>Definition 12.8.2</strong></p><p>A <em>connected components</em> of a graph is a subgraph consistingof some vertex and every node and edge that is connected to thatvertex.</p></blockquote><p>So a graph is connected iff it has exactly <spanclass="math inline">\(1\)</span> connected component. At the otherextreme, the empty graph on <span class="math inline">\(n\)</span>vertices has <span class="math inline">\(n\)</span> connectedcomponents, each connected component consisting of a single vertex.</p><h5 id="odd-cycles-and-2-colorability">Odd cycles and2-Colorability</h5><blockquote><p><strong>Theorem 12.8.3</strong></p><p>The following graph properties are equivalent: 1. The graph containsan odd length cycle. 2. The graph is not 2-colorable. 3. The graphcontains an odd length closed walk.</p></blockquote><p>In other words, if a graph has any one of the three properties above,then it has all of the properties.</p><h4 id="eular-tours-hamiltonian-cycles">12.9 Eular Tours &amp;Hamiltonian Cycles</h4><p>An <em>Euler tour</em> of a graph is a closed walk that includesevery edge exactly once.</p><blockquote><p><strong>Theorem 12.9.1</strong></p><p>A connected graph has an <em>Euler tour</em> iff every vertex has<em>even</em> degree.</p></blockquote><p><em>Hamiltonian cycles</em> are the unruly cousins of Eulertours.</p><blockquote><p><strong>Definition 12.9.2</strong></p><p>A <em>hamiltonian cycle</em> in a graph <spanclass="math inline">\(G\)</span> is a cycle that visits every vertex in<span class="math inline">\(G\)</span> exactly once. Similarly, ahamiltonian path is a path in <span class="math inline">\(G\)</span>that visits every vertex exactly once.</p></blockquote><h4 id="k-connected-graphs">12.10 k-connected Graphs</h4><blockquote><p><strong>Definition 12.8.4</strong></p><p>Two vertices in a graph are <spanclass="math inline">\(k\)</span>-edge connected when they remainconnected in every subgraph obtained by deleting up to <spanclass="math inline">\(k-1\)</span> edges. A graph with two or morevertices is <span class="math inline">\(k\)</span>-edge connected whenevery pair of distinct vertices in the graph are <spanclass="math inline">\(k\)</span>-edge connected.</p></blockquote><p>Two vertices are <span class="math inline">\(k\)</span>-edgeconnected when it takes at least <span class="math inline">\(k\)</span>"edge-failures" to disconnect them.</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;MCS的一点阅读笔记（更新时间：2023-12-26）&lt;/strong&gt;</summary>
    
    
    
    <category term="数学笔记" scheme="https://idealine9.github.io/categories/%E6%95%B0%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数学" scheme="https://idealine9.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
</feed>
